'''
3x5 한 숫자당 켜져있는(#) 곳은 무조건 켜져있어야함
숫자랑 켜져있는 곳이 모두 일치하면 그 숫자는 가능함
'''
num_dict = {
    0: [['#','#', '#'],
        ['#','.', '#'],
        ['#','.', '#'],
        ['#','.', '#'],
        ['#','#', '#']],
    1: [['.','.', '#'],
        ['.','.', '#'],
        ['.','.', '#'],
        ['.','.', '#'],
        ['.','.', '#']],
    2: [['#','#', '#'],
        ['.','.', '#'],
        ['#','#', '#'],
        ['#','.', '.'],
        ['#','#', '#']],
    3: [['#','#', '#'],
        ['.','.', '#'],
        ['#','#', '#'],
        ['.','.', '#'],
        ['#','#', '#']],
    4: [['#','.', '#'],
        ['#','.', '#'],
        ['#','#', '#'],
        ['.','.', '#'],
        ['.','.', '#']],
    5: [['#','#', '#'],
        ['#','.', '.'],
        ['#','#', '#'],
        ['.','.', '#'],
        ['#','#', '#']],
    6: [['#','#', '#'],
        ['#','.', '.'],
        ['#','#', '#'],
        ['#','.', '#'],
        ['#','#', '#']],
    7: [['#','#', '#'],
        ['.','.', '#'],
        ['.','.', '#'],
        ['.','.', '#'],
        ['.','.', '#']],
    8: [['#','#', '#'],
        ['#','.', '#'],
        ['#','#', '#'],
        ['#','.', '#'],
        ['#','#', '#']],
    9: [['#','#', '#'],
        ['#','.', '#'],
        ['#','#', '#'],
        ['.','.', '#'],
        ['#','#', '#']],
}
n = int(input())
graph = [ list(map(str, input())) for _ in range(5) ]
num_list=list()
'''
1:3
2:7
3:11
'''
def check(col):
    global ch
    possible = list()
    ch=0
    for num in range(10):
        flag=0
        for i in range(5):
            for j in range(3):
                if graph[i][col+j]=='#' and num_dict[num][i][j]=='.':
                    flag=1
                    break
            if flag==1:
                break
        # flag=1 이면, num 숫자는 가능함
        if flag==0:
            ch=1
            possible.append(num)
    # ch 0이면, 해당 층은 숫자후보가 아예 없음
    # 즉 -1, 종료
    if ch==0:
        print(-1)
        exit()
    num_list.append(possible)

# O (n * 15 * 10)
for i in range(0, n*4-1, 4):
    check(i)

rec = [0]*(n)
ans=0
cnt=0

'''
[1,9]
[2,3,4]
[7]
127 137 147
927 937 947
'''
# 각 자릿수마다 가능한 후보의 갯수
num_cnt = [0]*n
# 가능한 모든 경우의 수
total=1
for i in range(n):
    num_cnt[i] = len(num_list[i])
    if num_cnt[i]==0:
        num_cnt[i]=1
    total *= num_cnt[i]

'''
[전체 경우의 수] / [해당 자릿수의 후보리스트 갯수]
하면 해당 자릿수의 후보 숫자가 몇번 더해지는지 알수있음
O(최대 10 * 10) 안에 끝낼 수 있음
'''
ans, cnt = 0, 0
for idx, nums in enumerate(num_list):
    for idx2, num in enumerate(nums):
        k = num * pow(10, n-idx-1) * total / num_cnt[idx]
        ans+= k
print(ans/total)




        



